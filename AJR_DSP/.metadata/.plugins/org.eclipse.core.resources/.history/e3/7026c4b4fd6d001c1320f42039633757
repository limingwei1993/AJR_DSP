/*
  ******************************************************************************
  * @file    user_Main.c
  * @author  JYS
  * @version V1.0.0
  * @date    2020-06-10
  * @brief   Init
  */

#include "user_main.h"

#include "string.h"
#include "stdio.h"
#define test_SD    0      /* 测试使用，置1后打开测试SD卡功能，置0则关闭*/
#define test_SDRAM 1      /* 测试使用，置1后打开测试与FPGA通信的功能，置0则关闭*/
#define test_DAC   0      /* 测试使用，置1后打开测试DAC功能，置0则关闭*/
#define test_RS232 0      /* 测试使用，置1后打开测试RS232功能，置0则关闭*/
#define test_SOV   0      /* 测试使用，置1后打开测试SOV功能，置0则关闭*/
#define test_ABSW  0      /* 测试使用，置1后打开测试ABSW功能，置0则关闭*/
uint8_t POWER_SOV = 0;    /* 测试使用，控制SOV参数*/
uint8_t POWER_ABSW = 1;   /* 测试使用，控制ABSW参数*/

RX_FPGA_DATA Receive_Machine_Parameters; /*从FPGA接收的设备状态参数*/
TX_FPGA_DATA Transmit_Machine_Parameters;  /*发往FPGA控制设备状态的参数*/
uint16_t MCB_Receive_Data[0x30] = {0};/* 接收来自FPGA的数据*/
uint16_t MCB_Trismit_Data[20] = {0};/* 发送到FPGA的数据*/

uint8_t test_DAC_1=0;     /*测试使用，置1控制DAC1*/
uint8_t test_DAC_2=0;     /*测试使用，置1控制DAC2*/
uint16_t DAC_ValueO = 0;  /*测试使用，输出DAC1的值*/
uint16_t DAC_ValueI = 0;  /*测试使用，输出DAC1的值*/

FATFS   fs;         /*测试使用，测试SD卡*/
FIL     file;       /*测试使用，测试SD卡*/
uint8_t test_sd_read=0;/*测试使用，置1读取SD卡*/
uint8_t test_sd_write=0;/*测试使用，置1写数据到SD卡*/
uint8_t sd_write_buff[120]={0};/*测试使用，写入SD卡的数据*/
uint8_t sd_read_buff[120]={0};/*测试使用，保存从SD卡读取的数据*/
uint8_t readlen=0;/*测试使用，从SD卡读取的数据长度*/
uint8_t SDRAM_RxTx=0;     /*FPGA读写数据的标志*/
inC_Brake test_inC;
outC_Brake test_outC;
void user_main(void)
{
    int i;
    /*************以下初始化**************/
    _enable_interrupt_(); /*使能中断*/
    _enable_IRQ();        /*使能中断*/
    rtiInit();            /*初始化定时器*/
    DAC5689_Init();       /*DAC5689初始化*/
    gioInit();            /*I/O 初始化*/
    muxInit();            /*引脚分配 初始化*/
    Sdram_Init();         /*SDRAM总线 初始化*/
    sciInit();            /*RS232 初始化*/
    rtiEnableNotification(rtiNOTIFICATION_COMPARE0); /*使能定时器COMPARE0 5ms*/
    rtiStartCounter(rtiCOUNTER_BLOCK0);  /*开始定时器BLOCK0计数*/
    delay_ms(100);
    canREG1->TIOC &=(~0x00000008);   /*can1_tx as i/o  to DSP_CL_N_SOV */
    canREG1->TIOC |= 0x00000004;     /*can1_tx output */
    canREG3->TIOC &=(~0x00000008);   /*can1_tx as i/o  to DSP_CL_AB_SW_SOL */
    canREG3->TIOC |= 0x00000004;     /*can1_tx output */
    SD_GPIO_Init();    /*SD卡I/O 口初始化*/
    /*************以上初始化**************/
    /*************以下测试程序，SD卡**************/
#if test_SD==1
    if(f_mount(&fs,"0:",1) != FR_OK)/*用于测试SD卡，挂在文件系统*/
    {
        RS232_Send(18,"\r\nSD_CARD_LOAD_ERR\r\n");/*测试使用，SD卡挂载失败，RS232上报*/
    }
    /*************以上测试SD卡**************/
#endif
    while (1)
    {
    /*************以下测试程序，ASSW**************/
#if test_ABSW==1
        /******以下测试程序，控制ABSW*******/
        set_SOL(POWER_ABSW);
        /******以上测试程序，控制*******/
#endif
    /*************以上测试程序，ASSW**************/
    /*************以下测试程序，SOV**************/
#if test_SOV==1
        /******以下测试程序，控制SOV*******/
        set_SOV(POWER_SOV);
        /******以上测试程序，控制*******/
#endif
   /*************以上测试程序，SOV**************/
   /*************以下测试程序，SD卡**************/
#if test_SD==1
        /******以下测试程序，SD卡*******/
        if(test_sd_write==1)/*测试使用，写数据到SD卡*/
       {
          f_open (&file,  (const TCHAR *)"0:30.txt",  FA_OPEN_ALWAYS | FA_WRITE);  /*新建文件并打开*/
          for(i=0;i<100;i++)  /*给往SD卡写的数据赋值*/
          {
              if(sd_write_buff[i]<0xff)
               sd_write_buff[i]=sd_write_buff[i]+0x30;
              else
                  sd_write_buff[i]=0;
          }
          f_puts(sd_write_buff, &file); /*写数据到缓存*/
          f_sync(&file);  /*将缓存区的数据写到文件*/
          f_close (&file); /*关闭文件*/
          test_sd_write=0; /*此次写数据到SD卡结束*/
       }
        if(test_sd_read==1)/*测试使用，从SD卡读取数据*/
        {
            f_open (&file,  (const TCHAR *)"0:30.txt",FA_READ); /*打开文件*/
            f_read (&file, sd_read_buff, 100, &readlen); /*读数据*/
            f_close (&file); /*关闭文件*/
            test_sd_read=0;  /*此次读数据从SD卡结束*/
            for(i=0;i<100;i++) /*比较读写SD卡的数据*/
            {
                 if(sd_read_buff[i]!=sd_write_buff[i])  /*比较SD卡的读写是否一致，不一致上报错误信息。*/
                 {
                     RS232_Send(18,"\r\nsd_write_buff=\r\n");
                     RS232_Send(100,sd_write_buff);
                     RS232_Send(17,"\r\nsd_read_buff=\r\n");
                     RS232_Send(100,sd_read_buff);
                     i=100;
                 }
            }
        }
        /******以上测试程序，SD卡*******/
#endif
      /*************以上测试程序，SD卡**************/
      /*************以下与FPGA通信**************/
#if test_SDRAM==1
        /******以下读FPGA*******/
        if(SDRAM_RxTx==1) /*5ms*/
        {

             /*置1输出。   将IO扣配置为读取来自PFGA数据的模式*/
             hetPORT1->DIR &= (~ 0x0555DC00);    /*INPUT--DATA:10-12 14-16 18 20 22 24 26*/
             hetPORT1->DIR |= 0x500003BF;        /*OUTPUT--ADDR:0-5  7-9 28 30*/
             gioPORTA->DIR &= (~ 0X000000E4);    /*INPUT--DATA:2 5 6 7*/
             canREG2->TIOC &=(~0x00000008);      /*can2_tx as i/o  to ADDR_A6*/
             canREG2->TIOC |= 0x00000004;        /*can2_tx output*/
             canREG2->RIOC &=(~0x0000000C);      /*can2_Rx as i/o  to DATA_A12   INPUT*/
             mibspiREG5->PC0 &=(~0x00000200);    /*mbspi_clkx as i/o  to clk*/
             mibspiREG5->PC1 |=0x00000200;       /*mbspi_clkx output*/
             mibspiREG5->PC0 &=(~0x00000001);    /*mbspi_cS as i/o  to cS*/
             mibspiREG5->PC1 |=(0x00000001);     /*mbspi_CS output*/
             /*读取0x01--0x11的数据*/
            for(i=0;i<0x11;i++)
            {
               SDRAM_Read_Data((i+1),&MCB_Receive_Data[i]);
            }
            /*读取0x20--0x2D的数据*/
            for(i=0x1f;i<0x2D;i++)
            {
              SDRAM_Read_Data((i+1),&MCB_Receive_Data[i]);
            }
            /*以下将从FPGA读取到的数据赋值给设备的状态参数*/
            Receive_Machine_Parameters.Right_Inboard_Brake_Control_Valve_Current=MCB_Receive_Data[0];
            Receive_Machine_Parameters.Left_Inboard_Brake_Control_Valve_Current=MCB_Receive_Data[1];
            Receive_Machine_Parameters.INBD_RT_BPSI=MCB_Receive_Data[2];
            Receive_Machine_Parameters.INBD_LT_BPSI=MCB_Receive_Data[3];
            Receive_Machine_Parameters.Shut_off_valve_current_detection=MCB_Receive_Data[4];
            Receive_Machine_Parameters.Right_inner_wheel_speed=MCB_Receive_Data[5];
            Receive_Machine_Parameters.Left_inner_wheel_speed=MCB_Receive_Data[6];
            Receive_Machine_Parameters.Right_inner_wheel_temperature=MCB_Receive_Data[7];
            Receive_Machine_Parameters.Left_inner_wheel_temperature=MCB_Receive_Data[8];
            Receive_Machine_Parameters.Main_drivers_right_pedal=MCB_Receive_Data[9];
            Receive_Machine_Parameters.Main_drivers_left_pedal=MCB_Receive_Data[10];
            Receive_Machine_Parameters.Co_pilots_right_pedal=MCB_Receive_Data[11];
            Receive_Machine_Parameters.Co_pilots_left_pedal=MCB_Receive_Data[12];
            Receive_Machine_Parameters.Automatic_brake_selection_switch=(MCB_Receive_Data[13] >> 0) &0x01;
            Receive_Machine_Parameters.Automatic_brake_selector_switch_low=(MCB_Receive_Data[13] >> 1) &0x01;
            Receive_Machine_Parameters.Automatic_brake_selector_switch_middle=(MCB_Receive_Data[13] >> 2) &0x01;
            Receive_Machine_Parameters.Automatic_brake_selector_switch_high=(MCB_Receive_Data[13] >> 3) &0x01;
            Receive_Machine_Parameters.Automatic_brake_selection_switch_RTO=(MCB_Receive_Data[13] >> 4) &0x01;
            Receive_Machine_Parameters.Inner_wheel_ABS_start_signal=(MCB_Receive_Data[13] >> 5) &0x01;
            Receive_Machine_Parameters.Parking_brake_signal=(MCB_Receive_Data[13] >> 6) &0x01;
            Receive_Machine_Parameters.Spoiler_signal=(MCB_Receive_Data[13] >> 8) &0x01;
            Receive_Machine_Parameters.Throttle_signal=(MCB_Receive_Data[13] >> 9) &0x01;
            Receive_Machine_Parameters.Wheel_signal=(MCB_Receive_Data[13] >> 10) &0x01;
            Receive_Machine_Parameters.Handle_signal=(MCB_Receive_Data[13] >> 11) &0x01;
            Receive_Machine_Parameters.Standby_signal=(MCB_Receive_Data[13] >> 12) &0x01;
            Receive_Machine_Parameters.PIN_PGR_1=(MCB_Receive_Data[13] >> 13) &0x01;
            Receive_Machine_Parameters.PIN_PGR_2=(MCB_Receive_Data[13] >> 14) &0x01;
            Receive_Machine_Parameters._429_Communication[0]=MCB_Receive_Data[15];
            Receive_Machine_Parameters._429_Communication[1]=MCB_Receive_Data[16];
        /******以上，读FPGA*******/
            Brake(&test_inC, &test_outC);
        /******以下，写FPGA*******/
            /*置1输出。将IO扣配置为发送数据到PFGA的模式*/
              hetPORT1->DIR |=  0x0555DC00;      /*0NPUT--DATA:10-12 14-16 18 20 22 24 26*/
              hetPORT1->DIR |= 0x500003BF;       /*OUTPUT--ADDR:0-5  7-9 28 30*/
              gioPORTA->DIR |=  0X000000E4;      /*0NPUT--DATA:2 5 6 7*/
              canREG2->TIOC &=(~0x00000008);     /*can2_tx as i/o  to ADDR_A6*/
              canREG2->TIOC |= 0x00000004;       /*can2_tx output*/
              canREG2->RIOC &=(~0x00000008);     /*can2_Rx as i/o  to DATA_A12*/
              canREG2->RIOC |=0x00000004;        /*can2_Rx  0NPUT*/
              mibspiREG5->PC0 &=(~0x00000200);   /*mbspi_clkx as i/o  to clk*/
              mibspiREG5->PC1 |=0x00000200;      /*mbspi_clkx output*/
              /*将控制设备的参数赋给发送到FPGA的数据*/
              MCB_Trismit_Data[0]=Transmit_Machine_Parameters._429_Communication[0];
              MCB_Trismit_Data[1]=Transmit_Machine_Parameters._429_Communication[1];
              MCB_Trismit_Data[2]=0;
              MCB_Trismit_Data[3]=0;
              MCB_Trismit_Data[4]=Transmit_Machine_Parameters.ARM_SIG | (Transmit_Machine_Parameters.Left_wheel_speed_output_signal <<1) | (Transmit_Machine_Parameters.Right_wheel_speed_output_signal);
              MCB_Trismit_Data[5]=Transmit_Machine_Parameters.Pressure_signal_LT;
              MCB_Trismit_Data[6]=Transmit_Machine_Parameters.Pressure_signal_RT;
              MCB_Trismit_Data[7]=Transmit_Machine_Parameters.Inner_wheel_control_valve_current_signal_LT;
              MCB_Trismit_Data[8]=Transmit_Machine_Parameters.Inner_wheel_control_valve_current_signal_RT;
              MCB_Trismit_Data[9]=Transmit_Machine_Parameters.Inner_wheel_speed_LT;
              MCB_Trismit_Data[10]=Transmit_Machine_Parameters.Inner_wheel_speed_RT;
              MCB_Trismit_Data[11]=Transmit_Machine_Parameters.Inner_wheel_shut_off_valve_signal;
              MCB_Trismit_Data[12]=Transmit_Machine_Parameters.BRK_PDL_CH1_PLT_LT_pedal_signal;
              MCB_Trismit_Data[13]=Transmit_Machine_Parameters.BRK_PDL_CH1_PLT_RT_pedal_signal;
              MCB_Trismit_Data[14]=Transmit_Machine_Parameters.BRK_PDL_CH1_CPLT_LT_pedal_signal;
              MCB_Trismit_Data[15]=Transmit_Machine_Parameters.BRK_PDL_CH1_CPLT_RT_pedal_signal;
              /*发送地址0x40--0x4f的数据*/
              set_sdram_cs(1);
              for(i=0;i<0xf;i++)
             {
                SDRAM_Write_Data(0x40+i,MCB_Trismit_Data[i]);
             }
             SDRAM_RxTx=0;
        }
        /******以上写FPGA*******/
#endif
       /*************以上与FPGA通信**************/
       /*************以下测试程序，DAC**************/
#if test_DAC==1
        /******以下测试程序，控制DAC*******/
        if(test_DAC_1==1) /*测试DAC1*/
        {
            DAC5689_SetVoltage_mv(DAC_O,DAC_ValueO);
        }
        if(test_DAC_2==1)/*测试DAC2*/
        {

            DAC5689_SetVoltage_mv(DAC_I,DAC_ValueI);
        }
        /******以上测试程序，控制DAC*******/
#endif
        /*************以上测试程序，DAC**************/
        /*************以下测试程序，RS232**************/
#if test_RS232==1
        /*******以下测试RS232****************8*/
        if(rs232_send_len !=rs232_recive_len)  /*RS232有接收到新的数据。将新接收的数据发送出去*/
        {

            if(rs232_recive_len>rs232_send_len)
            {
              RS232_Send(rs232_recive_len-rs232_send_len,&temp_Recive_buf[rs232_send_len]);
              rs232_send_len=rs232_recive_len;

            }
            else if(rs232_recive_len<rs232_send_len)
            {
              RS232_Send(1000-rs232_send_len,&temp_Recive_buf[rs232_send_len]);
              RS232_Send(rs232_recive_len,&temp_Recive_buf[0]);
              rs232_send_len=rs232_recive_len;
            }

        }
        /*******以上测试RS232****************8*/
#endif
        /*************以上测试程序，RS232**************/
    }
}
/**********************
 * void SD_GPIO_Init(void)
 * SD卡的I/O口初始化
 * ********************/
void SD_GPIO_Init(void)
{
    spiREG3->PC0 &=(~0x00000fff);    /*mbspi cs ENA CLK SIMO SOMI as i/o  to SCLK CS MOSI MISO     0--GPIO*/
    spiREG3->PC1 |=0x00000806;       /*mbspi_clkx output     0--INPUT  1--OUTPUT*/
    spiREG3->PC1 &=(~0x00000100);       /*mbspi_clkx output     0--INPUT  1--OUTPUT*/
}
